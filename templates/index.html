    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" href="static/styles.css">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Sofia">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Cabin:ital,wght@0,400..700;1,400..700&family=League+Spartan:wght@100..900&family=Outfit:wght@100..900&display=swap" rel="stylesheet">

        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

        <title>MetaHacks</title>

    </head>
    <body>

    <div id="headercontainer">
        <section id="buttons">
            <a href="#section-one">
                <i class="fa-solid fa-house"></i>
            </a>
            <a href="#section-two">
                <i class="fa-solid fa-book"></i>
            </a>
            <a href="#section-three">
                <i class="fa-solid fa-info"></i>
            </a>
        </section>
    </div>
    
    <div id="landingPageContainer">
        <h1 id="landingPageHeader">Nimbus Notes</h1>
        <img src="static/images/person.png" id="personImg" class="landingImg">
        <img src="static/images/background.png" id="backgroundImg">
        <img src="static/images/cloud1.png" id="cloud1Img" class="landingImg">
        <img src="static/images/cloud2.png" id="cloud2Img" class="landingImg">
    </div>

    <h1 id="mainheading">Demonstrating<span class="gradienttext"> Nimbus Notes: </span></h1>

    <section id="section-two">
        <div id="maincontainer">
            <ul class="tabs">
                <li data-tab-target="#home" class="active tab"><i class="fa-solid fa-house"></i></li>
                <li data-tab-target="#course1" class="tab">MATH 115</li>
                <li data-tab-target="#course2" class="tab">MATH 117</li>
                <li data-tab-target="#course3" class="tab">ECE 150</li>
                <li data-tab-target="#course4" class="tab">ECE 105</li>
                <li data-tab-target="#course5" class="tab">ENG 101</li>
            </ul>
        

            <div id="home" data-tab-content class="active" data-tab-name="HOME">
                <h2 id="hometext">Lorem ipsum dolor sit amet consectetur adipisicing elit. Provident sed velit temporibus sint quis, dolorum alias, atque necessitatibus culpa veritatis esse rerum nobis ullam libero recusandae? Ducimus eaque fugiat aliquid. Lorem ipsum dolor sit amet consectetur adipisicing elit. Aspernatur beatae dolor doloremque repellendus reprehenderit illo impedit corporis id numquam fugit provident fugiat doloribus tenetur itaque architecto assumenda, possimus placeat consequuntur?</h2>
            </div>
            <div id="course1" data-tab-content data-tab-name="math115">
                <div class="container">
                    <div class="textcontainer">
                        <button class="recordButton"><i class="fa-solid fa-microphone"></i></button>
                    </div>
                    <div class="generatecontainer">
                        <h1 id="result-textmath115" class="generatetext"></h1>
                    </div>
                </div>
                <div class="flashcardcontainer">
                    <h1 id="card-textmath115">Math115flashcard</h1>
                    <button class="regenbutton" id="regen-textmath115">Regenerate <i class="fa-solid fa-rotate-right"></i></button>
                </div>
            </div>
            <div id="course2" data-tab-content data-tab-name="math117">
                <div class="container">
                    <div class="textcontainer">
                        <button class="recordButton"><i class="fa-solid fa-microphone"></i></button>
                    </div>
                    <div class="generatecontainer">
                        <h1 id="result-textmath117" class="generatetext"></h1>
                    </div>
                </div>
            </div>
            <div id="course3" data-tab-content data-tab-name="ece150">
                <div class="container">
                    <div class="textcontainer">
                        <button class="recordButton"><i class="fa-solid fa-microphone"></i></button>
                    </div>
                    <div class="generatecontainer">
                        <h1 id="result-textece150" class="generatetext"></h1>
                    </div>
                </div>
            </div>
            <div id="course4" data-tab-content data-tab-name="ece105">
                <div class="container">
                    <div class="textcontainer">
                        <button class="recordButton"><i class="fa-solid fa-microphone"></i></button>
                    </div>
                    <div class="generatecontainer">
                        <h1 id="result-textece105" class="generatetext"></h1>
                    </div>
                </div>
            </div>
            <div id="course5" data-tab-content data-tab-name="eng101">
                <div class="container">
                    <div class="textcontainer">
                        <button class="recordButton"><i class="fa-solid fa-microphone"></i></button>
                    </div>
                    <div class="generatecontainer">
                        <h1 id="result-texteng101" class="generatetext"></h1>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <secion id="section-three">
        <div id="informationcontainer">
            <h1 id="informationheader">Why did we make<span class="gradienttext"> Nimbus Notes?</span></h1>
            <p id="informationparagraph">Nimbus Notes first listens alongside you during classes with a simple press of the button, but it’s also very time-consuming to relisten to lectures. So, Nimbus Notes also generates a comprehensive summary once you click stop recording. After it finishes, it’ll create a flashcard to test your knowledge of the topic all powered by the Llama 3.2 3B model run locally on the machine.</p>
        </div>
    </secion>



    <script>
        const tabs = document.querySelectorAll("[data-tab-target]")
        const tabContents = document.querySelectorAll("[data-tab-content]")

        tabs.forEach(tab => {
            tab.addEventListener("click", () => {
                const target = document.querySelector(tab.dataset.tabTarget)
                tabContents.forEach(tabContent => {
                    tabContent.classList.remove("active")
                })
                tabs.forEach(tab => {
                    tab.classList.remove("active")
                })
                tab.classList.add("active")
                target.classList.add("active")
                getSummary(target.getAttribute("data-tab-name"))
                getCards(target.getAttribute("data-tab-name"))
            })
        })

        document.querySelectorAll(".regenbutton").forEach(button => {
            button.addEventListener("click", async() => {
                const parentTab = button.closest("[data-tab-content]");
                const tabName = parentTab ? parentTab.getAttribute("data-tab-name") || "Recording" : "Recording";
                
                generateCards(tabName)
            })
        })

        document.querySelectorAll(".recordButton").forEach(button => {
            let mediaRecorder;
            let stream;
            button.addEventListener("click", async () => {
                const parentTab = button.closest("[data-tab-content]");
                const tabName = parentTab ? parentTab.getAttribute("data-tab-name") || "Recording" : "Recording";

                // Check if the button is already recording
                if (button.classList.contains("recording")) {
                    // Stop the recording
                    mediaRecorder.stop();
                    button.classList.remove("recording");
                    return;
                }

                // Start a new recording
                button.classList.add("recording");

                // Request a new audio stream for each recording
                stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const audioChunks = [];
                mediaRecorder = new MediaRecorder(stream);

                // Collect audio data
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);

            // Save the file when recording stops
            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: "audio/webm; codecs=opus" }); // Ensure proper MIME type

                // Decode the audio to get PCM data
                const audioContext = new AudioContext();
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                // Encode the decoded audio as a WAV file
                const wavData = encodeWAV(audioBuffer);

                // Create a WAV Blob
                const wavBlob = new Blob([wavData], { type: "audio/wav" });

                // Send the WAV file to the backend or download it
                await testSendtoBackend(wavBlob, tabName);
                await generateCards(tabName);
                /*
                const url = URL.createObjectURL(blob);

                // Suggest a folder name in the filename
                const a = document.createElement("a");
                a.style.display = "none";
                a.href = url;
                a.download = `${tabName}.wav`; // Suggest folder structure in the filename
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);*/
                // testSendtoBackend(blob, tabName);
            };

                // Start recording
                mediaRecorder.start();

            // Stop the stream and cleanup if the tab changes
            button.addEventListener("click", () => {
                if (mediaRecorder.state === "recording") {
                    mediaRecorder.stop();
                    button.classList.remove("recording");
                }
                stream.getTracks().forEach(track => track.stop()); // Stop the stream
            }, { once: true });
        });
    });

    // Helper function to encode PCM data to WAV format
    function encodeWAV(audioBuffer) {
        const numChannels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const numSamples = audioBuffer.length;
        const buffer = new ArrayBuffer(44 + numSamples * numChannels * 2); // 16-bit PCM
        const view = new DataView(buffer);

        // Write WAV header
        writeString(view, 0, "RIFF");
        view.setUint32(4, 36 + numSamples * numChannels * 2, true); // File size
        writeString(view, 8, "WAVE");
        writeString(view, 12, "fmt ");
        view.setUint32(16, 16, true); // Subchunk1 size
        view.setUint16(20, 1, true); // Audio format (PCM)
        view.setUint16(22, numChannels, true); // Number of channels
        view.setUint32(24, sampleRate, true); // Sample rate
        view.setUint32(28, sampleRate * numChannels * 2, true); // Byte rate
        view.setUint16(32, numChannels * 2, true); // Block align
        view.setUint16(34, 16, true); // Bits per sample
        writeString(view, 36, "data");
        view.setUint32(40, numSamples * numChannels * 2, true); // Data chunk size

        // Write interleaved PCM samples
        let offset = 44;
        for (let sampleIndex = 0; sampleIndex < numSamples; sampleIndex++) {
            for (let channel = 0; channel < numChannels; channel++) {
                const sample = audioBuffer.getChannelData(channel)[sampleIndex];
                const intSample = Math.max(-1, Math.min(1, sample)) * 0x7FFF; // Scale to 16-bit PCM
                view.setInt16(offset, intSample, true);
                offset += 2;
            }
        }

        return buffer;
    }

    // Helper function to write a string into the DataView
    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }

    async function testSendtoBackend(audioBlob, tabName) {
        const formData = new FormData();
        formData.append('audio', audioBlob, 'recording.wav');

        try {
            const response = await fetch("/to_back/".concat(tabName), {
                method: "POST",
                body: formData
            });
            let result = await response.text();

            const animatedText = document.getElementById('result-text'.concat(tabName));

            let index = 0;
            animatedText.textContent = ""; // Clear previous text
            animatedText.style.opacity = 1; // Ensure element is visible

            const intervalId = setInterval(() => {
                animatedText.textContent += result[index];
                index++;

                if (index === result.length) {
                    clearInterval(intervalId);
                    // Animation complete - do any post-animation actions here
                }

            }, 10); // Adjust the interval (milliseconds) for typing speed
            
        } catch (error) {
            // Handle errors gracefully
            const resultTextElement = document.getElementById("result-text".concat(tabName));
            if (resultTextElement) {
                resultTextElement.textContent = `Error: ${error.message}`;
            }
        }
    }

    async function getSummary(tabName) {
        result = "";
        try {
            const response = await fetch("/get_summary/".concat(tabName), {
                method: "POST",
            });
            let result = await response.text();

            if (result != "false"){
                const animatedText = document.getElementById('result-text'.concat(tabName));

                let index = 0;
                animatedText.textContent = ""; // Clear previous text
                animatedText.style.opacity = 1; // Ensure element is visible

                const intervalId = setInterval(() => {
                    animatedText.textContent += result[index];
                    index++;

                    if (index === result.length) {
                        clearInterval(intervalId);
                        // Animation complete - do any post-animation actions here
                    }

                }, 10); // Adjust the interval (milliseconds) for typing speed
            }
            if(result == "false"){
                result = "Start recording now..."
                console.log("no text")
                const animatedText = document.getElementById('result-text'.concat(tabName));

                let index = 0;
                animatedText.textContent = ""; // Clear previous text
                animatedText.style.opacity = 1; // Ensure element is visible

                const intervalId = setInterval(() => {
                    animatedText.textContent += result[index];
                    index++;

                    if (index === result.length) {
                        clearInterval(intervalId);
                        // Animation complete - do any post-animation actions here
                    }

                }, 10); // Adjust the interval (milliseconds) for typing speed
            }
            
        } catch (error) {
            // Handle errors gracefully
            const resultTextElement = document.getElementById("result-text".concat(tabName));
            if (resultTextElement) {
                resultTextElement.textContent = `Error: ${error.message}`;
            }
        }

    }
    async function generateCards(tabName) {
      try {
          const response = await fetch("/gen_cards/".concat(tabName), {
              method: "POST",
          });
          let result = await response.text();
          if (result != "false") {
              const obj = JSON.parse(result);
              console.log("Flashcards generated for " + tabName);
              const questionText = document.getElementById('card-text'.concat(tabName));
              //const ansText = document.getElementById('flashcard-atext'.concat(tabName));
              questionText.textContent = obj["card1"]["q"];
              //ansText.textContent = obj["card1"]["a"];
          } else {
              const questionText = document.getElementById('card-text'.concat(tabName));
              //const ansText = document.getElementById('flashcard-atext'.concat(tabName));
              questionText.textContent = "No info";
              //ansText.textContent = "No info";
              console.log("No flashcards found for " + tabName);
          }
          
      } catch (error) {
          // Handle errors gracefully
          const resultTextElement = document.getElementById("card-text".concat(tabName));
          if (resultTextElement) {
              resultTextElement.textContent = `Error: ${error.message}`;
          }
      } 
    }
    async function getCards(tabName) {
      // THE REASON THIS ERRORS IS BECAUSE THE FLASHCARD DIVS HAVE BEEN CHANGED
      try {
          const response = await fetch("/get_cards/".concat(tabName), {
              method: "POST",
          });
          let result = await response.text();
          if (result != "false") {
              const obj = JSON.parse(result);
              console.log("Flashcards generated for " + tabName);
              const questionText = document.getElementById('card-text'.concat(tabName));
              //const ansText = document.getElementById('flashcard-atext'.concat(tabName));
              questionText.textContent = obj["card1"]["q"];
              ansText.textContent = obj["card1"]["a"];
          } else {
              const questionText = document.getElementById('card-text'.concat(tabName));
              //const ansText = document.getElementById('flashcard-atext'.concat(tabName));
              questionText.textContent = "No info";
              //ansText.textContent = "No info";
              console.log("No flashcards found for " + tabName);
          }

          
      } catch (error) {
          console.log(`Error: ${error.message}`)
      } 
    }

    const cloud1 = document.getElementById('cloud1Img');
    const cloud2 = document.getElementById('cloud2Img');
    
    const landingHeader = document.getElementById('landingPageHeader');
    window.addEventListener('scroll', () => {
        const scrollPosition = window.scrollY;
        cloud1.style.transform = `translate(${300 + scrollPosition * 0.4}px, ${300 + scrollPosition * 0.1}px)`;
        cloud2.style.transform = `translate(${-900 + scrollPosition * -0.4}px, ${300 + scrollPosition * 0.1}px)`;
        landingHeader.style.transform = `translate(0, ${scrollPosition * 0.3}%)`;
    });

    document.querySelectorAll('.flashcard').forEach(card => {
    card.addEventListener('click', () => {
        // Toggle a "flipped" class on the card when clicked
        card.classList.toggle('flipped');
    });
});

    </script>
    </body>
    </html>