    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" href="static/styles.css">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Sofia">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Cabin:ital,wght@0,400..700;1,400..700&family=Nunito:ital,wght@0,200..1000;1,200..1000&family=Varela+Round&display=swap" rel="stylesheet">

        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

        <title>MetaHacks</title>

    </head>
    <body>

    <div id="headercontainer">
        <section id="buttons">
            <a href="#section-one">
                <i class="fa-solid fa-house"></i>
            </a>
            <a href="#section-two">
                Test
            </a>
            <a href="#">
                Information
            </a>
        </section>
    </div>
    <section id="section-one">
        <img src="static/images/main.png" id="mainimg">
    </section>
    <section id="section-two">
        <div id="maincontainer">
            <ul class="tabs">
                <li data-tab-target="#home" class="active tab"><i class="fa-solid fa-house"></i></li>
                <li data-tab-target="#course1" class="tab">MATH 115</li>
                <li data-tab-target="#course2" class="tab">MATH 117</li>
                <li data-tab-target="#course3" class="tab">ECE 150</li>
                <li data-tab-target="#course4" class="tab">ECE 105</li>
                <li data-tab-target="#course5" class="tab">ENG 101</li>
            </ul>
        
            <div class="tab-content">
                <div id="home" data-tab-content class="active" data-tab-name="HOME">
                    <h1>Study better.</h1>
                </div>
                <div id="course1" data-tab-content data-tab-name="math115">
                    <h1>Math 115 Content</h1>
                    <div id="response-container">
                        <p id="response">Result will be displayed here after recording.</p>
                    </div>
                    <button class="recordButton"><i class="fa-solid fa-microphone"></i></button>
                </div>
                <div id="course2" data-tab-content data-tab-name="math117">
                    <h1>Course 2 Content</h1>
                    <button class="recordButton"><i class="fa-solid fa-microphone"></i></button>
                </div>
                <div id="course3" data-tab-content data-tab-name="ece150">
                    <h1>Course 3 Content</h1>
                    <button class="recordButton"><i class="fa-solid fa-microphone"></i></button>
                </div>
                <div id="course4" data-tab-content data-tab-name="ece105">
                    <h1>Course 4 Content</h1>
                    <button class="recordButton"><i class="fa-solid fa-microphone"></i></button>
                </div>
                <div id="course5" data-tab-content data-tab-name="eng101">
                    <h1>Course 5 Content</h1>
                    <button class="recordButton"><i class="fa-solid fa-microphone"></i></button>
                </div>
            </div>
        </div>
    </section>


    <script>
        const tabs = document.querySelectorAll("[data-tab-target]")
        const tabContents = document.querySelectorAll("[data-tab-content]")

        tabs.forEach(tab => {
            tab.addEventListener("click", () => {
                const target = document.querySelector(tab.dataset.tabTarget)
                tabContents.forEach(tabContent => {
                    tabContent.classList.remove("active")
                })
                tabs.forEach(tab => {
                    tab.classList.remove("active")
                })
                tab.classList.add("active")
                target.classList.add("active")
            })
        })

        document.querySelectorAll(".recordButton").forEach(button => {
            button.addEventListener("click", async () => {
                const parentTab = button.closest("[data-tab-content]");
                const tabName = parentTab ? parentTab.getAttribute("data-tab-name") || "Recording" : "Recording";

                // Check if the button is already recording
                if (button.classList.contains("recording")) {
                    // Stop the recording
                    mediaRecorder.stop();
                    button.classList.remove("recording");
                    return;
                }

                // Start a new recording
                button.classList.add("recording");

                // Request a new audio stream for each recording
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const audioChunks = [];
                const mediaRecorder = new MediaRecorder(stream);

                // Collect audio data
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);

            // Save the file when recording stops
            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: "audio/webm; codecs=opus" }); // Ensure proper MIME type

                // Decode the audio to get PCM data
                const audioContext = new AudioContext();
                const arrayBuffer = await audioBlob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                // Encode the decoded audio as a WAV file
                const wavData = encodeWAV(audioBuffer);

                // Create a WAV Blob
                const wavBlob = new Blob([wavData], { type: "audio/wav" });

                // Send the WAV file to the backend or download it
                testSendtoBackend(wavBlob, tabName);
                /*
                const url = URL.createObjectURL(blob);

                // Suggest a folder name in the filename
                const a = document.createElement("a");
                a.style.display = "none";
                a.href = url;
                a.download = `${tabName}.wav`; // Suggest folder structure in the filename
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);*/
                // testSendtoBackend(blob, tabName);
            };

                // Start recording
                mediaRecorder.start();

            // Stop the stream and cleanup if the tab changes
            button.addEventListener("click", () => {
                if (mediaRecorder.state === "recording") {
                    mediaRecorder.stop();
                    button.classList.remove("recording");
                }
                stream.getTracks().forEach(track => track.stop()); // Stop the stream
            }, { once: true });
        });
    });

    // Helper function to encode PCM data to WAV format
    function encodeWAV(audioBuffer) {
        const numChannels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const numSamples = audioBuffer.length;
        const buffer = new ArrayBuffer(44 + numSamples * numChannels * 2); // 16-bit PCM
        const view = new DataView(buffer);

        // Write WAV header
        writeString(view, 0, "RIFF");
        view.setUint32(4, 36 + numSamples * numChannels * 2, true); // File size
        writeString(view, 8, "WAVE");
        writeString(view, 12, "fmt ");
        view.setUint32(16, 16, true); // Subchunk1 size
        view.setUint16(20, 1, true); // Audio format (PCM)
        view.setUint16(22, numChannels, true); // Number of channels
        view.setUint32(24, sampleRate, true); // Sample rate
        view.setUint32(28, sampleRate * numChannels * 2, true); // Byte rate
        view.setUint16(32, numChannels * 2, true); // Block align
        view.setUint16(34, 16, true); // Bits per sample
        writeString(view, 36, "data");
        view.setUint32(40, numSamples * numChannels * 2, true); // Data chunk size

        // Write interleaved PCM samples
        let offset = 44;
        for (let sampleIndex = 0; sampleIndex < numSamples; sampleIndex++) {
            for (let channel = 0; channel < numChannels; channel++) {
                const sample = audioBuffer.getChannelData(channel)[sampleIndex];
                const intSample = Math.max(-1, Math.min(1, sample)) * 0x7FFF; // Scale to 16-bit PCM
                view.setInt16(offset, intSample, true);
                offset += 2;
            }
        }

        return buffer;
    }

    // Helper function to write a string into the DataView
    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }


    async function testSendtoBackend(audioBlob, tabName) {
        const formData = new FormData();
        formData.append('audio', audioBlob, 'recording.wav');

        try {
            const response = await fetch("/to_back/".concat(tabName), {
                method: "POST",
                body: formData
            });
            const result = await response.text();

            // Update the HTML with the result
            const responseContainer = document.getElementById("response");
            responseContainer.textContent = `Backend Response: ${result}`;
        } catch (error) {
            // Display an error message in the HTML
            const responseContainer = document.getElementById("response");
            responseContainer.textContent = `Error: ${error.message}`;
        }
    }

    </script>
    </body>
    </html>